use std::env;
use std::process;
use getopts::{Options, Matches};

const PROGRAM: &'static str = "troll";

pub struct Config {
    pub token: String,
    pub channel_name: String,
    pub username: String,
    pub message: String,
}

pub fn args() -> Config {
    match parse_args() {
        Ok(conf) => conf,
        Err(err) => {
            println!("{}", err);
            process::exit(1);
        }
    }
}

pub fn parse_args() -> Result<Config, String> {
    let args: Vec<String> = env::args().collect();

    let mut opts = Options::new();

    opts.reqopt("t", "token", "You must provide the access token.", "TOKEN");
    opts.reqopt("c", "channel", "You must provide the channel name.", "CHANNEL");
    opts.reqopt("u", "username", "You must provide the username.", "USERNAME");
    opts.reqopt("m", "message", "You must provide the message you want to ouput.", "MESSAGE");
    opts.optflag("h", "help", "Print this help menu.");

    let matches = match opts.parse(&args[1..]) {
        Ok(m) => m,
        Err(_) => {
            print_usage(opts);
            process::exit(1);
        }
    };

    let conf = Config {
        token: try!(opt_result("t", &matches)),
        channel_name: try!(opt_result("c", &matches)),
        username: try!(opt_result("u", &matches)),
        message: try!(opt_result("m", &matches)),
    };

    Ok(conf)
}

fn print_usage(opts: Options) {
    let brief = format!("Usage: ./{} [options]", PROGRAM);
    print!("{}", opts.usage(&brief));
}

fn opt_result(opt: &str, matches: &Matches) -> Result<String, String> {
    let err = format!("Invalid argument for option \"{}\"", opt);
    matches.opt_str(opt).ok_or(err)
}
